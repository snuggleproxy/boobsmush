<html onmousemove="m(event)">
	<head>
	<script>

        function Griddle(){
            griddle = new Object(); //hha, wut does new even mean?
            griddle.xlims=[];
            griddle.ylims=[];
            griddle._add = function(smol,larg,cuts,zone){
                let innit = false;
                // check for smol b4 the rest
                if(cuts.length==0){
                    cuts.push([smol,[zone]]);
                    cuts.push([larg,[]]);
                }else{
                    if(smol<cuts[0][0]){
                        // cause there isn't already a cut b4 the first cut
                        cuts.splice(0,0,[smol,[zone]]);
                        innit = true;
                    }else if(smol==cuts[0][0]){
                        cuts[0][1].push(zone);
                        innit = true;
                    }
                    for (let ii=1;ii<cuts.length;ii++){
                        //fuck readability [0] is the xcoordinate. talk to author if u wanna understand shit
                        //eet my cnt
                        if(innit){
                            if(larg>cuts[ii][0]){
                                //put
                                cuts[ii][1].push(zone);
                            }else if(larg==cuts[ii][0]){
                                break;
                            }else{
                                //new
                                koopa = [...cuts[ii-1][1]];
                                troopa = [larg,koopa];
                                cuts.splice(ii,0,troopa);
                                //delete zone from this range
                                cuts[ii][1].pop();// we shud reasonably kno it only appears in
                                                        // that one spot we just added, so don't do
                                                        // the below flibbidy bibbidy.
                               // for(let jj=0;jj<cuts[ii].length;jj++){//sick index names dude!
                               //     if(cuts[ii][1][jj]==zone){
                               //         cuts[ii][1].splice(jj,1);
                               //     }
                               // }
                                break;
                            }
                        }else{//by elimination, this is NOT INNIT!!!
                            // add ob to existing or new range
                            if(smol==cuts[ii][0]){
                                //put
                                cuts[ii][1].push(zone);
                                innit = true;
                            }else if(smol<cuts[ii][0]){
                                //new
                                let new_cut = [smol,[...cuts[ii-1][1], zone]];
                                // this adds one to the length of the xlims
                                // but doesn't add one to are index@!?!?
                                // Isn't that a problme u ask!? NO!
                                // U see, we need to check this one again
                                // checking it for the end of the new zone!
                                // now u see!^^
                                cuts.splice(ii,0,new_cut);
                                innit = true;
                            }//else do nuthing u fuk
                        }
                    }
                    if(!innit){//smol>cuts[cuts.length-1])
                            // it's already there
                        //cuts[cuts.length-1][1].push(zone);
                        cuts.push([smol,[zone]]);
                        cuts.push([larg,[]]);
                    }else if(larg>cuts[cuts.length-1][0]){
                            // it's already there
                        //cuts[cuts.length-1][1].push(zone);
                        cuts.push([larg,[]]);
                    }
                }
            }
            griddle.add = function(x1,y1,x2,y2,zone){
                this._add(x1,x2,this.xlims,zone);
                this._add(y1,y2,this.ylims,zone);
            }
            griddle._del = function(smol,larg,cuts,zone){
                // ourder
                let innit = false;
                for (let ii=0;  ii<cuts.length && cuts.length>0;  ii++){
                    //fuck readability [0] is the xcoordinate. talk to author if u wanna understand shit
                    if(innit){
                        // TODO: deduplicate shit in this algorithmmm
                        //remove zone from cut
                        for(let jj=0;jj<cuts[ii][1].length;jj++){//good index names bro
                            if(cuts[ii][1][jj]==zone){
                                //do the splice!
                                cuts[ii][1].splice(jj,1);
                                jj--;
                            }
                        }
                        //see if we're at the end
                        if(cuts[ii][0]==larg){
                            //remove cut if applickableh
                            // This will happen on the first and last...
                            /// but only almost all of the time!
                            // TODO: is this more general than need be?
                            if (ii==0){
                                if(cuts[ii][1].length == 0){
                                    cuts.splice(ii,1);// almost impossible for this to happen right?
                                                    // but not impossible right?
                                                // still, you'd have to be implementing some bullshizz for
                                            // it to ever be relevent
                                        // but fuck it it werkz so ehhhhhhhhhhh.........
                                }
                            }else if(cuts[ii][1].length == cuts[ii-1][1].length ){
                                let samlish = true;
                                for(let jj=0;jj<cuts[ii][1].length;jj++){//i'm unfin' over those index names
                                    if(cuts[ii][1][jj] != cuts[ii-1][1][jj]){
                                        samlish=false;
                                        break;// this break we kno they ain't same..
                                    }// write more code than the other language to keep fresh!
                                }
                                if(samlish){
                                    cuts.splice(ii,1);
                                }
                            }
                            break;// this break is cauze we done the zone
                        }
                    }else{
                        //look for start if u kno wut i mean
                        if(cuts[ii][0]==smol){
                            innit=true;
                            //remove zone from cut
                            for(let jj=0;jj<cuts[ii][1].length;jj++){//good index names bro
                                if(cuts[ii][1][jj]==zone){
                                    //do the splice!
                                    cuts[ii][1].splice(jj,1);
                                    jj--;
                                }
                            }
                            //remove cut if applickableh
                            // This will happen on the first and last...
                            /// but only almost all of the time!
                            if (ii==0){
                                if(cuts[ii][1].length == 0){
                                    cuts.splice(ii,1);
                                    ii--;
                                }
                            }else if(cuts[ii][1].length == cuts[ii-1][1].length ){
                                let samlish = true;
                                for(let jj=0;jj<cuts[ii][1].length;jj++){//i'm unfin' over those index names
                                    if(cuts[ii][1][jj] != cuts[ii-1][1][jj]){
                                        samlish=false;
                                        break;
                                    }// write more code than the other language to keep fresh!
                                }
                                if(samlish){
                                    cuts.splice(ii,1);
                                    ii--;
                                }
                            }
                        }
                    }
                }/// yeah nested shit is kinky!
            }
            griddle.del = function(x1,y1,x2,y2,zone){
                this._del(x1,x2,this.xlims,zone);
                this._del(y1,y2,this.ylims,zone);
            }
            return griddle;
        }
        window.mcgriddle = Griddle();
        window.freshest_id = 0;
        function get_childz(ob){
                ob.x += xchange;
                ob.y += ychange;
                ob.rejig();
                for (ii=0;ii<ob.babbs.length;ii++){
                    move_ob(ob.babbs[ii],xchange,ychange);
                }
        }
        window.trigs=[];
        function Trig(ob){
            trig = document.createElement("div");
            trig.innerHTML="*";
            trig.style.position = 'absolute';
            trig.x = x-4;
            trig.y = y-6;
            trig.rejig = function(){
                this.style.left = this.x;
                this.style.top = this.y;
            };
            trig.rejig();
            document.body.appendChild(trig);
            ob.trigs.push(trig);
            trigs.push(trig);
            trig.move = function(xchange,ychange){
                // TODO: OH NO!!! It's looping through all trigs and looking at each trig, how did I not notice... I am dum
                for(let ii=0; ii<trigs.length; ii++){
                    if(trigs[ii]==trig){
                        trigs.splice(ii,1);
                        ii--;//TODO: this shouldn't be needed, every trig is here once.
                    }
                }
                this.x += xchange;
                this.y += ychange;
                this.rejig();
                trigs.push(trig); /// TODO: wait, wut does this even do? trigs should always have all trigs???
                let nu_zones = this.wut_zones();
                //compare zones
                let samlish = false;
                if(nu_zones.length == this.in_the_zone.length ){
                    samlish = true;
                    for(let jj=0;jj<nu_zones.length;jj++){//i'm unfin' over those index names
                        if(nu_zones[jj] != this.in_the_zone[jj]){
                            samlish=false;
                            break;// this break we kno they ain't same..
                        }// write more code than the other language to keep fresh!
                    }
                }
                this.in_the_zone = this.wut_zones();
                if(!samlish){
                    this.init_duck_fucking();
                }
            }
            trig.titilation = 0;
            trig.aroused = false;
            trig.init_duck_fucking = function(){
                this.titilation = 10;
                if(!this.aroused){
                    this.style.color="yellow";
                    this.aroused=true;
                    this.fuck_a_duck(this);
                }
            }
            trig.fuck_a_duck = function(fck){
                fck.titilation--;
                if(fck.titilation==0){
                    fck.style.color="black";
                    fck.aroused=false;
                }else{
                    setTimeout(fck.fuck_a_duck, 100, fck);
                }// I'm sorry u had to witness this... why r u even tho?
            }
            trig.wut_zones = function(){
                let xs = [];
                if(mcgriddle.xlims.length>0 && this.x>=mcgriddle.xlims[0][0]){
                    for (let ii=1; ii<mcgriddle.xlims.length; ii++){
                        if(this.x<mcgriddle.xlims[ii][0]){
                            xs = mcgriddle.xlims[ii-1][1];
                            break;
                        }
                    }
                }
                let ys = [];
                if(mcgriddle.xlims.length>0 && this.y>=mcgriddle.ylims[0][0]){
                    for (let ii=1; ii<mcgriddle.ylims.length; ii++){
                        if(this.y<mcgriddle.ylims[ii][0]){
                            ys = mcgriddle.ylims[ii-1][1];
                            break;
                        }
                    }
                }
                let innn = [];
                for(let ii=0; ii<xs.length; ii++){
                    for(let jj=0; jj<ys.length; jj++){
                        //TODO: this could be more efficient
                        if(xs[ii]==ys[jj]){
                            innn.push(xs[ii]);
                            break;
                        }
                    }
                }
                return(innn);
            }
            trig.in_the_zone = trig.wut_zones();
        }
        function Zone(ob){
            zone = svglayer.cloneNode();// fuck how do you create svg
            zone.xxx = x;
            zone.yyy = y;
            zone.www = 10;
            zone.hhh = 10;
            zone.rejig = function(){
                this.style.left = this.xxx;
                this.style.top = this.yyy;
            }
            // ahhhhhhhhhhhhhhhhhhhhhh
            // btdubz this is used for changing size while drawin zone
            //    and NAWT used for moving the zone!
            zone.movelines = function(xchange,ychange){
                boobs = this.getElementsByTagName("line");
                for (let ii=0;ii<boobs.length;ii++){
                    boobs[ii].x1.baseVal.value += xchange;
                    boobs[ii].x2.baseVal.value += xchange;
                    boobs[ii].y1.baseVal.value += ychange;
                    boobs[ii].y2.baseVal.value += ychange;
                }
                
            }
            zone.resize = function(){
                this.style.height = this.hhh;
                this.style.width = this.www;
            }
            zone.resize();
            zone.rejig();
            ob.zones.push(zone);
            document.body.appendChild(zone);
            zone.move = function(xchange,ychange){
                mcgriddle.del(this.xxx,this.yyy,this.xxx+this.www,this.yyy+this.hhh,this);
                this.xxx = this.xxx+xchange;
                this.yyy = this.yyy+ychange;
                this.rejig();
                mcgriddle.add(this.xxx,this.yyy,this.xxx+this.www,this.yyy+this.hhh,this);
            }
        }
        function Ob(mom){
            ob = document.createElement("canvas");
            ob.style.position = 'absolute';
            ob.x = x;
            ob.y = y;
            ob.width=10;
            ob.height=10;
            ob.id=freshest_id++;
            ob.liner = liner.cloneNode();
            svglayer.appendChild(ob.liner);
            ob.rejig = function(){
                this.style.left = this.x;
                this.style.top = this.y;
                    this.liner.x1.baseVal.value= this.x;
                    this.liner.y1.baseVal.value= this.y;
                    if(this.mom){
                        this.liner.x2.baseVal.value = this.mom.x;
                        this.liner.y2.baseVal.value = this.mom.y;
                    } else {
                        this.liner.x2.baseVal.value = 0;
                        this.liner.y2.baseVal.value = 0;
                    }

            };
            ob.style.border='dashed';
            ob.ctx=ob.getContext('2d');
            if(mom){// there should only be one object without a mom.
                ob.mom = mom;
                mom.babbs.push(ob);
            }
            ob.rejig();
            ob.zones = [];
            ob.trigs = [];
            ob.babbs = [];
            ob.move = function(xchange,ychange){
                this.x += xchange;
                this.y += ychange;
                this.rejig();
                for (let ii=0;ii<this.babbs.length;ii++){
                    this.babbs[ii].move(xchange,ychange);
                }
                for (let ii=0;ii<this.zones.length;ii++){
                    this.zones[ii].move(xchange,ychange);
                }
                for (let ii=0;ii<this.trigs.length;ii++){
                    this.trigs[ii].move(xchange,ychange);
                }
            };

            //ob.beginPath();
            //ob.rect(0, 0, canvas.width, canvas.height);
            //ob.fillStyle = 'yellow';
            //ob.fill();
            ob.select = function(){
                //// old selected
                if(selected_ob.style){
                    selected_ob.style.borderWidth=1;
                }
                // zones
                if(selected_ob.zones)
                    for (let ii=0;ii<selected_ob.zones.length;ii++){
                        selected_ob.zones[ii].style.visibility="hidden";
                }
                //// new selected!!!
                selected_ob = this;
                selected_ob.style.borderWidth=3;
                // zones
                for (let ii=0;ii<selected_ob.zones.length;ii++){
                        selected_ob.zones[ii].style.visibility="visible";
                }

            }
            ob.hl = function(){
                if(hl_ob!=selected_ob && hl_ob.style){
                  hl_ob.style.borderWidth=1;
                  //console.log("some programmer round here is dum. dunno who.");
                }
                if(this.style && this!=selected_ob){
                    this.style.borderWidth = 2;
                }
                hl_ob = this;
            }
            ob.select();
            document.body.appendChild(ob);    
            all_obs.push(ob);
            return(ob)
        }
        // uhh, shouldn't some of this be in init? do we even need init? How does loading werk?
        pencil_down = false;

        window.get_closest = function(){
                let min = 190099;
                let closest = 0;
                // this is bad I guess... too much proc
                for(ii=0;ii<all_obs.length;ii++){
                    let ib = all_obs[ii];
                    let ic = Math.abs(x-parseInt(ib.style.left))
                            +Math.abs(y-parseInt(ib.style.top));
                    if( ic<min ){
                        min = ic;
                        closest = ii;
                    }
                }
            return(closest);
        }
        // it goes [0] is onclick and [1] is on move while clickd!!!
        // Oh, don't forget [2] is just moving! Also I'm dum and so iz code liek this!
            // no I don't know if this makes sense!
        window.input_fun={
            'movin_menu':[
                function(e){},
                function(e){
                    menu.style.left=parseInt(menu.style.left)+dx;
                    menu.style.top=parseInt(menu.style.top)+dy;
                },
                function(e){},
            ],
            'move':[
                function(e){
                    e.preventDefault();
                    // move center to cursor
                    closest = get_closest();
                    all_obs[closest].select();
                },
                function(e){
                    // move by dx & dy
                    selected_ob.move(dx,dy);
                },
                function(e){
                    closest = get_closest();
                    all_obs[closest].hl();
                            // wrong algorithm!!! thats for inside of!!!
                            //x>ib.left &&
                            //x<ib.left+ib.width &&
                            //y>ib.top &&
                            //y<ib.top+ib.height

                },
            ],
            'draw':[
                function(e){
                    e.preventDefault();
                },
                function(e){
                    drwrlineee(selected_ob,lastx,lasty,x,y);
                },
                function(e){},
            ],
            'new':[
                function(e){
                    e.preventDefault();
                    newob = Ob(selected_ob);
                },
                function(e){
                    // resize during creation
                    selected_ob.width+=dx;
                    selected_ob.height+=dy;
                },
                function(e){},
            ],
            'zone':[
                function(e){ //click
                    e.preventDefault();
                    Zone(selected_ob);
                },
                function(e){ //drag
                    e.preventDefault();
                    drwrzonee(selected_ob,lastx,lasty,x,y);
                },
                function(e){ //move
                },
            ],
            'trig':[
                function(e){ //click
                    e.preventDefault();
                    Trig(selected_ob);
                },
                function(e){ //drag
                    e.preventDefault();
                },
                function(e){ //move
                },
            ],
        }
        window.onmousedown=function(e){
            toolz = ['move','draw','new','zone','trig'];
            menux=parseInt(menu.style.left);
            menuy=parseInt(menu.style.top);
            if(x>menux && x<menux+menu.width){
                if(y>menuy){
                    if(y< menuy+10){
                        pencil_down=true;
                        last_input_mode = input_mode;
                        input_mode = 'movin_menu';
                    }else{
                        for(i=toolz.length-1;i>=0;i--){
                            if(y<menuy+(i+1)*40){ //TODO: probz don't hardcode this
                                input_mode = toolz[i]
                                menuhl.y.baseVal.value=5+i*40;
                            }
                        }
                    }
                }
                console.log(input_mode);
            }else{
                pencil_down=true;
                input_fun[input_mode][0](e);
            }
            firstx = x;
            firsty = y;
        }
        window.onmouseup=function(e){
            if(input_mode=='movin_menu'){
                input_mode=last_input_mode;
            }
            else if(input_mode=='zone' && pencil_down){
                //this is so bad
                drwrzonee(selected_ob,x,y,firstx,firsty);//TODO:make this get the obj it needs or not, cause just pencil tool.
                let zone = selected_ob.zones[selected_ob.zones.length-1];// hahahahahah
                mcgriddle.add(zone.xxx,zone.yyy,zone.xxx+zone.www,zone.yyy+zone.hhh,zone); // that input scheme u thought up is so bad.
                                                                                        // u gotta kill & fix it
                //drwrlineee(canvas,lastx,lasty,firstx,firsty);//TODO:make this get the obj it needs or not, cause just pencil tool.
            }
            pencil_down = false;
        }
        ////////////////
        // init function
        ////////////////
        window.onload=function(){

            window.all_obs = [];
            var w = window.innerWidth;
            var h = window.innerHeight;
            // fuck the canvas right up fukkkkkkk uuuuuuuuu
            var canvas = document.getElementById('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '0px';
            canvas.style.top = '0px';

            // custom cursorz r coool!
            document.body.style.cursor = "crosshair"

            window.menu = document.createElement("img");
            menu.style.position = 'absolute';
            menu.style.left=10;
            menu.style.top =10;
            menu.src = "toolbar2.png";
            menu.onmousedown=function(e){e.preventDefault()};
            document.body.appendChild(menu);
            window.input_mode = 'move';

            fuck_you=10;
            canvas.width=window.innerWidth-fuck_you;
            canvas.height=window.innerHeight-fuck_you;
            window.ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'red';
            ctx.fill();
            //drwrlineee(canvas,51,51,300,80);
            window.x=100;
            window.y=30;
            window.dx=0;
            window.dy=0;
            window.firstx=0;
            window.firsty=0;
            window.lastx=0;
            window.lasty=0;

            window.selected_ob = 'boobs';
            window.hl_ob = 'dickz';
            testob = Ob();
            window.ctx = testob.ctx;

            window.svglayer = document.getElementById("svglayer");
            svglayer.width.baseVal.value=window.innerWidth - fuck_you;
            svglayer.height.baseVal.value=window.innerHeight - fuck_you;
            window.menuhl = document.getElementById("menuhl");
            menuhl.x.baseVal.value=5;
            menuhl.y.baseVal.value=5;
            window.liner = document.getElementById("liner");
            liner.x1.baseVal.value= 1;
            liner.y1.baseVal.value= 1;
            liner.x2.baseVal.value= 2;
            liner.y2.baseVal.value= 2;
            //foo = liner.cloneNode();
            //svglayer.appendChild(foo);
        }
        function drwrlineee(ob,x1,y1,x2,y2){
            ctxxx = ob.getContext('2d');
            ctxxx.beginPath();
            ctxxx.moveTo(x1-ob.style.left.slice(0,-2),y1-ob.style.top.slice(0,-2));
            ctxxx.lineTo(x2-ob.style.left.slice(0,-2),y2-ob.style.top.slice(0,-2));
            ctxxx.stroke();
        }
        function drwrzonee(ob,x1,y1,x2,y2){
            foo = liner.cloneNode();
            zoo = ob.zones[ob.zones.length-1];
            zoo.appendChild(foo);
            foo.x1.baseVal.value = x1 - zoo.xxx;
            foo.y1.baseVal.value = y1 - zoo.yyy;
            foo.x2.baseVal.value = x2 - zoo.xxx;
            foo.y2.baseVal.value = y2 - zoo.yyy;
            // resize if drawing outside
            if(x2>zoo.xxx+zoo.www){
                zoo.www = x2-zoo.xxx;
                zoo.resize();
            }else if (x2<zoo.xxx){
                zoo.www += zoo.xxx-x2;
                zoo.resize();
                zoo.movelines(zoo.xxx-x2,0);
                zoo.xxx = x2;
                zoo.rejig();
            }
            if(y2>zoo.yyy+zoo.hhh){
                zoo.hhh = y2-zoo.yyy;
                zoo.resize();
            }else if (y2<zoo.yyy){
                zoo.hhh += zoo.yyy-y2;
                zoo.resize();
                zoo.movelines(0,zoo.yyy-y2);
                zoo.yyy = y2;
                zoo.rejig();
            }

        }
        // this is neat... delete it!!!!!
        function move(){
              bx = document.getElementById("box");

              hereXstr = bx.style.left;//.slice(0,bx.style.left.length-2);
              hereXstr.replace("px","");
              hereX = parseInt(hereXstr);

              hereYstr = bx.style.top;
              hereYstr.replace("px","");
              hereY = parseInt(hereYstr);

              thereX = x;
              thereY = y;

              newX = (4*hereX+thereX)/5;
              newY = (4*hereY+thereY)/5;
	      	  bx.style.left = newX;
	      	  bx.style.top = newY;

              if(Math.abs(thereX-hereX)>7 || Math.abs(thereY-hereY)>7)
                  doing = 1;
                  //setTimeout(function(){move(x,y);}, 100);
        }
		function m(e){
     //       if(goobable){
      //          goobable = false;
                lastx = x;
                lasty = y;
                x = e.pageX;
                y = e.pageY;
                dx = x-lastx;
                dy = y-lasty;
                if(pencil_down){
                    input_fun[input_mode][1](e);
                }else{
                    input_fun[input_mode][2](e);
                }
       //     } // goobable was a dum idea.
		}
     // window.goobable = false;
     // function goob(){
     //     goobable = true;
     // }
     //   window.setInterval(goob, 100);// doesn't even help with the multi babb issue.
	</script>
	</head>
	<body>
        <canvas id="canvas"></canvas>
        <svg id="svglayer" width="400" height="1000" style="position:absolute">
          <rect id="menuhl" x=100 y=100 width="38" height="38" style="fill:rgb(2550,100,100);stroke-width:4;stroke:rgb(0,0,0)" />
          <line id="liner" x1="0" y1="0" x2="300" y2="300" style="stroke:rgb(255,255,255);stroke-width:2" />
        </svg>
	</body>
</html>
