<html onmousemove="m(event)">
<head>
<script src="FileSaver.min.js"></script>
<script src="jszip.min.js"></script>
<script type="text/javascript" src="dist/jszip-utils.js"></script>
<script>


all_tocks=[];
freshest_tock_id=0;
function Tock(ob,fromStar,toStar){
    tock = new Object();
    tock.id = freshest_tock_id++;
    all_tocks.push(tock);
    tock.ob = ob;
    tock.fromStar = fromStar;
    tock.toStar = toStar;
    tock.tock = function(){
        this.toStar.make_current()
    }
    return(tock)
}
all_ticks=[];
freshest_tick_id=0;
function Tick(zone,trig,exit){
    tick = new Object();
    tick.id=freshest_tick_id++;
    console.log(all_ticks)
    all_ticks.push(tick);
    tick.exit = exit;
    tick.zone = zone;
    tick.trig = trig;
    tick.tocks = [];
    tick.tick = function(){
        for (let ii=0;ii<this.tocks.length;ii++){
            if(this.tocks[ii].ob.current_star==this.tocks[ii].fromStar){
                this.tocks[ii].tock()
            }
        }
    }
    tick.add_tock = function(tock){
        this.tocks.push(tock);
    }
    tick.rem_tock = function(tock){
        for (let ii=0;ii<this.tocks.length;ii++){
            if(this.tocks[ii]==tock){
                this.tocks.splice(ii,1);
            }
        }
    }
    return(tick)
}
ticks={};
function getTick(zone,trig,exit){
    if(ticks[zone.id]){
        if(ticks[zone.id][trig.id]){
            if(ticks[zone.id][trig.id][exit]){
                return(ticks[zone.id][trig.id][exit]);
            }else{
                ticks[zone.id][trig.id][exit] = Tick(zone,trig,exit);
                return(ticks[zone.id][trig.id][exit]);
            }
        }else{
            ticks[zone.id][trig.id] = {};
            ticks[zone.id][trig.id][exit] = Tick(zone,trig,exit);
            return(ticks[zone.id][trig.id][exit]);
        }
    }else{
        ticks[zone.id]={};
        ticks[zone.id][trig.id] = {};
        ticks[zone.id][trig.id][exit] = Tick(zone,trig,exit);
        return(ticks[zone.id][trig.id][exit]);
    }
}

function Griddle(){
    griddle = new Object(); //hha, wut does new even mean?
    griddle.xlims=[];
    griddle.ylims=[];
    griddle._add = function(smol,larg,cuts,zone){
        let innit = false;
        // check for smol b4 the rest
        if(cuts.length==0){
            cuts.push([smol,[zone]]);
            cuts.push([larg,[]]);
        }else{
            if(smol<cuts[0][0]){
                // cause there isn't already a cut b4 the first cut
                cuts.splice(0,0,[smol,[zone]]);
                innit = true;
            }else if(smol==cuts[0][0]){
                cuts[0][1].push(zone);
                innit = true;
            }
            for (let ii=1;ii<cuts.length;ii++){
                //fuck readability [0] is the xcoordinate. talk to author if u wanna understand shit
                //eet my cnt
                if(innit){
                    if(larg>cuts[ii][0]){
                        //put
                        cuts[ii][1].push(zone);
                    }else if(larg==cuts[ii][0]){
                        break;
                    }else{
                        //new
                        koopa = [...cuts[ii-1][1]];
                        troopa = [larg,koopa];
                        cuts.splice(ii,0,troopa);
                        //delete zone from this range
                        cuts[ii][1].pop();// we shud reasonably kno it only appears in
                                                // that one spot we just added, so don't do
                                                // the below flibbidy bibbidy.
                       // for(let jj=0;jj<cuts[ii].length;jj++){//sick index names dude!
                       //     if(cuts[ii][1][jj]==zone){
                       //         cuts[ii][1].splice(jj,1);
                       //     }
                       // }
                        break;
                    }
                }else{//by elimination, this is NOT INNIT!!!
                    // add ob to existing or new range
                    if(smol==cuts[ii][0]){
                        //put
                        cuts[ii][1].push(zone);
                        innit = true;
                    }else if(smol<cuts[ii][0]){
                        //new
                        let new_cut = [smol,[...cuts[ii-1][1], zone]];
                        // this adds one to the length of the xlims
                        // but doesn't add one to are index@!?!?
                        // Isn't that a problme u ask!? NO!
                        // U see, we need to check this one again
                        // checking it for the end of the new zone!
                        // now u see!^^
                        cuts.splice(ii,0,new_cut);
                        innit = true;
                    }//else do nuthing u fuk
                }
            }
            if(!innit){//smol>cuts[cuts.length-1])
                    // it's already there
                //cuts[cuts.length-1][1].push(zone);
                cuts.push([smol,[zone]]);
                cuts.push([larg,[]]);
            }else if(larg>cuts[cuts.length-1][0]){
                    // it's already there
                //cuts[cuts.length-1][1].push(zone);
                cuts.push([larg,[]]);
            }
        }
    }
    griddle.add = function(x1,y1,x2,y2,zone){
        this._add(x1,x2,this.xlims,zone);
        this._add(y1,y2,this.ylims,zone);
    }
    griddle._del = function(smol,larg,cuts,zone){
        // ourder
        let innit = false;
        for (let ii=0;  ii<cuts.length && cuts.length>0;  ii++){
            //fuck readability [0] is the xcoordinate. talk to author if u wanna understand shit
            if(innit){
                // TODO: deduplicate shit in this algorithmmm
                //remove zone from cut
                for(let jj=0;jj<cuts[ii][1].length;jj++){//good index names bro
                    if(cuts[ii][1][jj]==zone){
                        //do the splice!
                        cuts[ii][1].splice(jj,1);
                        jj--;
                    }
                }
                //see if we're at the end
                if(cuts[ii][0]==larg){
                    //remove cut if applickableh
                    // This will happen on the first and last...
                    /// but only almost all of the time!
                    // TODO: is this more general than need be?
                    if (ii==0){
                        if(cuts[ii][1].length == 0){
                            cuts.splice(ii,1);// almost impossible for this to happen right?
                                            // but not impossible right?
                                        // still, you'd have to be implementing some bullshizz for
                                    // it to ever be relevent
                                // but fuck it it werkz so ehhhhhhhhhhh.........
                        }
                    }else if(cuts[ii][1].length == cuts[ii-1][1].length ){
                        let samlish = true;
                        for(let jj=0;jj<cuts[ii][1].length;jj++){//i'm unfin' over those index names
                            if(cuts[ii][1][jj] != cuts[ii-1][1][jj]){
                                samlish=false;
                                break;// this break we kno they ain't same..
                            }// write more code than the other language to keep fresh!
                        }
                        if(samlish){
                            cuts.splice(ii,1);
                        }
                    }
                    break;// this break is cauze we done the zone
                }
            }else{
                //look for start if u kno wut i mean
                if(cuts[ii][0]==smol){
                    innit=true;
                    //remove zone from cut
                    for(let jj=0;jj<cuts[ii][1].length;jj++){//good index names bro
                        if(cuts[ii][1][jj]==zone){
                            //do the splice!
                            cuts[ii][1].splice(jj,1);
                            jj--;
                        }
                    }
                    //remove cut if applickableh
                    // This will happen on the first and last...
                    /// but only almost all of the time!
                    if (ii==0){
                        if(cuts[ii][1].length == 0){
                            cuts.splice(ii,1);
                            ii--;
                        }
                    }else if(cuts[ii][1].length == cuts[ii-1][1].length ){
                        let samlish = true;
                        for(let jj=0;jj<cuts[ii][1].length;jj++){//i'm unfin' over those index names
                            if(cuts[ii][1][jj] != cuts[ii-1][1][jj]){
                                samlish=false;
                                break;
                            }// write more code than the other language to keep fresh!
                        }
                        if(samlish){
                            cuts.splice(ii,1);
                            ii--;
                        }
                    }
                }
            }
        }/// yeah nested shit is kinky!
    }
    griddle.del = function(x1,y1,x2,y2,zone){
        this._del(x1,x2,this.xlims,zone);
        this._del(y1,y2,this.ylims,zone);
    }
    griddle.wut_zones = function(xpos, ypos){
        // returns the zones sorted order?
        let xs = [];
        if(this.xlims.length>0 && xpos>=this.xlims[0][0]){
            for (let ii=1; ii<this.xlims.length; ii++){
                if(xpos<this.xlims[ii][0]){
                    xs = this.xlims[ii-1][1];
                    break;
                }
            }
        }
        let ys = [];
        if(this.xlims.length>0 && ypos>=this.ylims[0][0]){
            for (let ii=1; ii<this.ylims.length; ii++){
                if(ypos<this.ylims[ii][0]){
                    ys = this.ylims[ii-1][1];
                    break;
                }
            }
        }
        let innn = [];
        for(let ii=0; ii<xs.length; ii++){
            for(let jj=0; jj<ys.length; jj++){
                //TODO: this could be more efficient
                if(xs[ii]==ys[jj]){
                    innn.push(xs[ii]);
                    break;
                }
            }
        }
        return(innn);
    }
    return griddle;
}
window.mcgriddle = Griddle();
window.freshest_id = 0;
window.trigs=[];
freshest_trig_id=0;
function Trig(ob){
    trig = document.createElement("div");
    trig.id=freshest_trig_id++;
    trigs.push(trig);
    ob.trigs.push(trig);
    trig.innerHTML="*";
    trig.style.position = 'absolute';
    trig.x = x;
    trig.y = y;
    trig.rejig = function(){
        this.style.left = this.x-2;
        this.style.top = this.y-4;
    };
    trig.rejig();
    document.body.appendChild(trig);
    trig.move = function(xchange,ychange){
        // TODO: OH NO!!! It's looping through all trigs and looking at each trig, how did I not notice... I am dum
        for(let ii=0; ii<trigs.length; ii++){
            if(trigs[ii]==trig){
                trigs.splice(ii,1);//remove
                ii--;//TODO: this shouldn't be needed, every trig is here once.
            }
        }
        this.x += xchange;
        this.y += ychange;
        this.rejig();
        trigs.push(trig); /// TODO: wait, wut does this even do? trigs should always have all trigs???

        //compare zones
        let zones_lost = [...this.in_the_zone];
        this.in_the_zone = mcgriddle.wut_zones(this.x,this.y);// freshen this trigs zones!
        let zones_gained = [...this.in_the_zone];

        let lostii=0;
        let nuii=0;
        while (lostii<zones_lost.length){
            if (zones_lost[lostii]==zones_gained[nuii]){
                zones_lost.splice(lostii,1);
                zones_gained.splice(nuii,1);
            }else{
                nuii++;
            }
            if (nuii>=zones_gained.length){// greater than for the edge case where there are no nu zones
                nuii=0;
                lostii++;
            }
        }

        let samlish = true;
        if(zones_lost.length>0){
            samlish=false;
            //do something with events?
            for (let ii=0; ii<zones_lost.length; ii++){
                let tick = getTick(zones_lost[ii],this,true);
                eventMenu.add_tick(tick);
                tick.tick();
            }
        }
        if(zones_gained.length>0){
            samlish=false;
            //do something with events?
            for (let ii=0; ii<zones_gained.length; ii++){
                let tick = getTick(zones_gained[ii],this,false);
                eventMenu.add_tick(tick);
                tick.tick();
            }
        }
        
        // old algorithm that only cared about if it changed, not how
       // let samlish = false;
       // if(nu_zones.length == this.in_the_zone.length ){
       //     samlish = true;
       //     for(let jj=0;jj<nu_zones.length;jj++){//i'm unfin' over those index names
       //         if(nu_zones[jj] != this.in_the_zone[jj]){
       //             samlish=false;
       //             break;// this break we kno they ain't same..
       //         }// write more code than the other language to keep fresh!
       //     }
       // }
        if(!samlish){
            this.init_duck_fucking();
        }
    }
    trig.titilation = 0;
    trig.aroused = false;
    trig.init_duck_fucking = function(){
        this.titilation = 3;
        if(!this.aroused){
            this.style.color="yellow";
            this.aroused=true;
            this.fuck_a_duck(this);
        }
    }
    trig.fuck_a_duck = function(fck){
        fck.titilation--;
        if(fck.titilation==0){
            fck.style.color="black";
            fck.aroused=false;
        }else{
            setTimeout(fck.fuck_a_duck, 100, fck);
        }// I'm sorry u had to witness this... why r u even tho?
    }
    trig.in_the_zone = mcgriddle.wut_zones(this.x,this.y);
}
freshest_zone_id = 0;
zones=[];
function Zone(ob){
    zone = svglayer.cloneNode();// fuck how do you create svg
    zone.id=freshest_zone_id++;
    zones.push(zone);
    zone.xxx = x;
    zone.yyy = y;
    zone.www = 10;
    zone.hhh = 10;
    zone.rejig = function(){
        this.style.left = this.xxx;
        this.style.top = this.yyy;
    }
    // ahhhhhhhhhhhhhhhhhhhhhh
    // btdubz this is used for changing size while drawin zone
    //    and NAWT used for moving the zone!
    zone.movelines = function(xchange,ychange){
        boobs = this.getElementsByTagName("line");
        for (let ii=0;ii<boobs.length;ii++){
            boobs[ii].x1.baseVal.value += xchange;
            boobs[ii].x2.baseVal.value += xchange;
            boobs[ii].y1.baseVal.value += ychange;
            boobs[ii].y2.baseVal.value += ychange;
        }
        
    }
    zone.resize = function(){
        this.style.height = this.hhh;
        this.style.width = this.www;
    }
    zone.resize();
    zone.rejig();
    ob.zones.push(zone);
    document.body.appendChild(zone);
    zone.move = function(xchange,ychange){
        mcgriddle.del(this.xxx,this.yyy,this.xxx+this.www,this.yyy+this.hhh,this);
        this.xxx = this.xxx+xchange;
        this.yyy = this.yyy+ychange;
        this.rejig();
        mcgriddle.add(this.xxx,this.yyy,this.xxx+this.www,this.yyy+this.hhh,this);
    }
}
freshest_ob_id = 0;
obs=[];
function Ob(mom){
    ob = document.createElement("canvas");
    ob.style.position = 'absolute';
    ob.x = x;
    ob.y = y;
    ob.width=10;
    ob.height=10;
    ob.id=freshest_ob_id++;
    obs.push(ob);
    ob.liner = liner.cloneNode();
    svglayer.appendChild(ob.liner);
    ob.rejig = function(){
        this.style.left = this.x;
        this.style.top = this.y;
            this.liner.x1.baseVal.value= this.x;
            this.liner.y1.baseVal.value= this.y;
            if(this.mom){
                this.liner.x2.baseVal.value = this.mom.x;
                this.liner.y2.baseVal.value = this.mom.y;
            } else {
                this.liner.x2.baseVal.value = 0;
                this.liner.y2.baseVal.value = 0;
            }

    };
    ob.style.border='dashed';
    ob.ctx=ob.getContext('2d');
    if(mom){// there should only be one object without a mom.
        ob.mom = mom;
        mom.babbs.push(ob);
    }
    ob.rejig();
    ob.zones = [];
    ob.trigs = [];
    ob.babbs = [];
    ob.move = function(xchange,ychange){
        this.x += xchange;
        this.y += ychange;
        this.rejig();
        for (let ii=0;ii<this.babbs.length;ii++){
            this.babbs[ii].move(xchange,ychange);
        }
        for (let ii=0;ii<this.zones.length;ii++){
            this.zones[ii].move(xchange,ychange);
        }
        for (let ii=0;ii<this.trigs.length;ii++){
            this.trigs[ii].move(xchange,ychange);
        }
    };

    //ob.beginPath();
    //ob.rect(0, 0, canvas.width, canvas.height);
    //ob.fillStyle = 'yellow';
    //ob.fill();
    //////////////////////////////////
    //  changing what ob's selected
    //////////////////////////////////
    ob.select = function(){
        //// old selected
        if(selected_ob.style){
        selected_ob.hide_stars();
            selected_ob.style.borderWidth=1;
        }
        // zones
        if(selected_ob.zones)
            for (let ii=0;ii<selected_ob.zones.length;ii++){
                selected_ob.zones[ii].style.visibility="hidden";
        }
        //// new selected!!!
        selected_ob = this;
        selected_ob.show_stars();
        selected_ob.style.borderWidth=3;
        // zones
        for (let ii=0;ii<selected_ob.zones.length;ii++){
                selected_ob.zones[ii].style.visibility="visible";
        }

    }
    ob.hl = function(){
        if(hl_ob!=selected_ob && hl_ob.style){
          hl_ob.style.borderWidth=1;
          //console.log("some programmer round here is dum. dunno who.");
        }
        if(this.style && this!=selected_ob){
            this.style.borderWidth = 2;
        }
        hl_ob = this;
    }
    // griddle for the stars!
    //TODO this doesn't need to happen
    //let strrr = Star(ob);
    //ob.stars = [strrr];
    ob.stars=[];
    // TODO: make logic for this!!!
    // I don't remember what was meant by this and I don't care. Maybe u will.
    ob.starmap = Griddle();
    //ob.starmap.add(strrr.x,strrr.y,strrr.x+strrr.width,strrr.y+strrr.height,strrr);
    //ob.current_star = strrr;
    ob.current_star = null;
    ob._new_star = function(tx,ty,current){
        star = Star(this,current);
        star.x=tx;
        star.y=ty;
        star.rejig();
        this.stars.push(star);
        if(current){
            star.make_current();
            //this.current_star=star;
        }
        this.starmap.add(star.x,star.y,star.x+star.width,star.y+star.height,star);
    }
    ob.new_star = function(){
        this._new_star(x,y,true);
    }
    ob.hide_stars = function(){
        for(let ii=0;ii<this.stars.length;ii++){
            this.stars[ii].hidden=true;
        }
    }
    ob.show_stars = function(){
        for(let ii=0;ii<this.stars.length;ii++){
            this.stars[ii].hidden=false;
        }
    }
    ob.hide_trigs = function(){
        for(let ii=0;ii<this.trigs.length;ii++){
            this.trigs[ii].style.visibility="hidden";
        }
    }
    ob.show_trigs = function(){
        for(let ii=0;ii<this.trigs.length;ii++){
            this.trigs[ii].style.visibility="";
        }
    }
    ob.putAway = function(){
        return [
            this.id,
            this.x,
            this.y,
            this.width,
            this.height,
        ];
    }
    ob.select();
    document.body.appendChild(ob);    
    all_obs.push(ob);
    return(ob)
}
Star = function(ob,current){
    star = document.createElement("canvas");
    star.ob = ob;
    star.current=current;
    if (current){
        star.ob.current_star=star;
    }
    star.img = new Image;
    star.style.position = 'absolute';
    star.width=50;
    star.height=50;
    star.x = ob.x-star.width-10;
    star.y = ob.y;
    star.style.border='solid';
    star.ctx=star.getContext('2d');
    star.rejig = function(){
        this.style.left = this.x;
        this.style.top = this.y;
    }
    star.rejig();
    star.update = function(){
        this.ob.toBlob((blob)=>{
            this.img.src=URL.createObjectURL(blob);
            this.img.onload=()=>{
                this.ctx.clearRect(0,0,this.width,this.height);
                let hr = this.ob.width/this.width;
                let wr = this.ob.height/this.height;
                // TODO: i didn't think hard enuf to make this good.
                let scale_ratio = hr>wr?hr:wr;
                let drwX=ob.width/scale_ratio;
                let drwY=ob.height/scale_ratio;
                for(let i=0;i<10;i++)
                this.ctx.drawImage(this.img,
                    (this.width-drwX)/2+i/10,
                    (this.width-drwY)/2+i/10,
                    drwX,drwY);
            }
            });
        //TODO: delete old url?
    }
    star.restore = function(){
        this.ob.ctx.clearRect(0,0,this.ob.width,this.ob.height);
        this.ob.ctx.drawImage(this.img,0,0);
    }
    star.time_tick = null;
    star.make_current = function(){
        if(this.time_tick){
            time_tick.set();
        }
        this.ob.current_star.current=false;
        this.ob.current_star=this;
        this.current=true;
        this.restore();
    }
    star.putAway = function(){
        return [
            this.ob.id,
            this.x,
            this.y,
            this.current
            ]
    }
    document.body.appendChild(star);
    return(star);
}

/////////////////////////////
// end of objects
/////////////////////////////

///////////////////////////
// begining of... not objects!
///////////////////////////


// uhh, shouldn't some of this be in init? do we even need init? How does loading werk?
pencil_down = false;

window.get_closest = function(){
        let min = 190099;
        let closest = 0;
        // this is bad I guess... too much proc
        for(ii=0;ii<all_obs.length;ii++){
            let ib = all_obs[ii];
            let ic = Math.abs(x-parseInt(ib.style.left))
                    +Math.abs(y-parseInt(ib.style.top));
            if( ic<min ){
                min = ic;
                closest = ii;
            }
        }
    return(closest);
}
// it goes [0] is onclick and [1] is on move while clickd!!!
// Oh, don't forget [2] is just moving! Also I'm dum and so iz code liek this!
    // no I don't know if this makes sense!
//
// TODO: remove all of this and just use a big ugly event parse tree
//
window.no_input_latch=false;
window.input_fun={
    'ticktock':[
        function(e){},
        function(e){},
        function(e){},
    ],
    'movin_menu':[
        function(e){},
        function(e){
            menu.style.left=parseInt(menu.style.left)+dx;
            menu.style.top=parseInt(menu.style.top)+dy;
        },
        function(e){},
    ],
    'play':[
        function(e){
            e.preventDefault();
                // move center to cursor
                //closest = get_closest();
                //all_obs[closest].select();
        },
        function(e){
                selected_ob.move(dx,dy);
        },
        function(e){
            //closest = get_closest();
                    // wrong algorithm!!! thats for inside of!!!
                    //x>ib.left &&
                    //x<ib.left+ib.width &&
                    //y>ib.top &&
                    //y<ib.top+ib.height

        },
    ],
    'move':[
        function(e){
            e.preventDefault();
            stars_in_tha_skyyyy=selected_ob.starmap.wut_zones(x,y);
            if(stars_in_tha_skyyyy.length > 0){
                no_input_latch=true;
                stars_in_tha_skyyyy[0].make_current();
            }else{
                // move center to cursor
                closest = get_closest();
                all_obs[closest].select();
            }
        },
        function(e){
            if(!no_input_latch){
                // move by dx & dy
                selected_ob.move(dx,dy);
            }
        },
        function(e){
            if(no_input_latch){
                no_input_latch=false;
            }
            closest = get_closest();
            all_obs[closest].hl();
                    // wrong algorithm!!! thats for inside of!!!
                    //x>ib.left &&
                    //x<ib.left+ib.width &&
                    //y>ib.top &&
                    //y<ib.top+ib.height

        },
    ],
    'draw':[
        function(e){
            e.preventDefault();
            if(x<selected_ob.x || x>selected_ob.x+selected_ob.width||
               y<selected_ob.y || y>selected_ob.y+selected_ob.height){
                //TODO: this should be creating the creation of a star!!!
                // PART OF A BEAUTIFUL CONSTELLATION!
                // NAWT A TRIG!
                //Trig(selected_ob);

                stars_in_tha_skyyyy=selected_ob.starmap.wut_zones(x,y);
                if(stars_in_tha_skyyyy.length > 0){
                    stars_in_tha_skyyyy[0].make_current();
                }else{
                    selected_ob.new_star();
                }
            }

        },
        function(e){
            drwrlineee(selected_ob,lastx,lasty,x,y);
        },
        function(e){},
    ],
    'new':[
        function(e){
            no_input_latch=true;
            e.preventDefault();
            newob = Ob(selected_ob);
        },
        function(e){
            // resize during creation
            selected_ob.width+=dx;
            selected_ob.height+=dy;
        },
        function(e){
            if(no_input_latch){
                no_input_latch=false;
                input_mode = 'draw';
                menuhl.y.baseVal.value=5+40;
            }
        },
    ],
    'zone':[
        function(e){ //click
            e.preventDefault();
            Zone(selected_ob);
        },
        function(e){ //drag
            e.preventDefault();
            drwrzonee(selected_ob,lastx,lasty,x,y);
        },
        function(e){ //move
        },
    ],
    'trig':[
        function(e){ //click
            e.preventDefault();
            Trig(selected_ob);
        },
        function(e){ //drag
            e.preventDefault();
        },
        function(e){ //move
        },
    ],
    'trash':[
        function(e){ //click
            // i dunno if this really makes sense
            e.preventDefault();
            alert("This doesnt do anything yet");
        },
        function(e){ //drag
            e.preventDefault();
        },
        function(e){ //move
        },
    ],
}
window.onmousedown=function(e){
    toolz = ['move','draw','new','zone','trig','trash','play','save'];
    menux=parseInt(menu.style.left);
    menuy=parseInt(menu.style.top);
    if( input_mode == 'ticktock' ){
        // over a star of the selected ob
        let stars_in_tha_skyyyy=selected_ob.starmap.wut_zones(x,y);
        if(stars_in_tha_skyyyy){
            tocking_fromStar = stars_in_tha_skyyyy[0];
        }else{
            input_mode = last_input_mode;
        }
    }else if(x>menux && x<menux+menu.width){
        if(y>menuy){
            if(y< menuy+10){
                pencil_down=true;
                last_input_mode = input_mode;
                input_mode = 'movin_menu';
            }else{
                for(i=toolz.length-1;i>=0;i--){
                    // it was setting the input mode to every one until it got to the correct one
                    // how silly
                    // past me wuz dum
                    if(y<menuy+(i+1)*40
                       &&
                       y>menuy+((i)*40)){ //TODO: probz don't hardcode this
                        let old_mode = input_mode;
                        input_mode = toolz[i]

                   //   if(old_mode == "draw" && input_mode != "draw"){
                   //       //suck it life!
                   //       selected_ob.hide_stars();
                   //   }
                   //   if(old_mode != "draw" && input_mode == "draw"){
                   //       //suck it life!
                   //       selected_ob.show_stars();
                   //   }

                        // move the dum tool selectorb
                        let old_menuhl = menuhl.y.baseVal.value;
                        console.log(old_menuhl);
                        menuhl.y.baseVal.value=5+i*40;
                        //TODO: this is the absolute worst fix this:
                        // fix this whole input schema
                        //  seperate on click functions. glifs in dif imgs & shiz

                        ///////////////////
                        // SAVE FUNCTION!!!!////////
                        //////////
                        if(input_mode=="save"){
                            // it took me a minute to code this one if statement.
                                                /// only code while drunk!!!!!!!!!!!!!^^^^^^^^^^^^^6
                                    // you can see my emotional stat in the six.
                                        // fuzziness is why it got there
                                            // that sentiment is why it stayed there.

                            input_mode = old_mode; // saving isn't a mode! Why are thingz like this!?!?!?
                            setTimeout(()=>{menuhl.y.baseVal.value=old_menuhl;},500);

                            var zip = new JSZip();


                            ////////////
                            ///  serialize all the thingz yo
                            //
                            let serializedSaveStuff = {
                                "Obs":[],
                                "Stars":[],
                                "Zones":[],
                                "Trigs":[],
                                "Ticks":[],
                                "Tocks":[]
                            };
                            all_obs.map((ob)=>{
                                let sob = ob.putAway();
                                serializedSaveStuff["Obs"].push(sob);
                                ob.stars.map((star)=>{
                                    let sstar = star.putAway();
                                    console.log(star,sstar);
                                    serializedSaveStuff["Stars"].push(sstar);
                                });
                           //     console.log(ob);
                           //     console.log(stringu);
                                return ob.putAway();
                            }),
                            console.log("serializedSaveStuff",serializedSaveStuff);
                            let dataaaaastring = JSON.stringify(serializedSaveStuff);
                            zip.file("Hello.txt", dataaaaastring);

                            let saveotron = function (content){
                                // see FileSaver.js
                                console.log("doing save");
                                saveAs(content, "example.zip");
                            }

                            var ob_saving_count = 0;
                            var ob_saving = true;
                            let globimgFolder = zip.folder("images");
                            obs.map((thisOb)=>{
                                ob_saving_count ++;// doing things this way could cause an error down
                                                // the line where the check to see if all the stars
                                                // for the ob have been converted to blobs double counts
                                                // (race condition, see below)
                                                // so if this seems to be a glitch ever change this to
                                                // an array system with names and blah blah blah

                                let imgFolder = globimgFolder.folder(thisOb.id);

                                thisOb.star_bloober_count=0;
                                thisOb.star_bloobing=true;
                                console.log(thisOb.stars);
                                /// if it got no stars save its img
                                if (thisOb.stars.length == 0){
                                    console.log(thisOb);
                                    thisOb.toBlob((bloob)=>{
                                        imgFolder.file("img.png", bloob);//, {base64: true});
                                        zip.generateAsync({type:"blob"}).then((content)=>{
                                            console.log("the old one image, eh!?");
                                                    saveotron(content);
                                        });
                                    });
                                }
                                /// otherwise just save it's stars
                                for (let ii = 0; ii < thisOb.stars.length; ii++){
                                    let star = thisOb.stars[ii];
                                    thisOb.star_bloober_count++;
                                    //star.img.toBlob((bloob)=>{
                                    fetch(star.img.src).then((r)=>{//r => r.blob());
                                        let bloob = r.blob();
                                        imgFolder.file(ii+".png", bloob);//, {base64: true});


                                        zip.generateAsync({type:"blob"}).then((content)=>{
                                            thisOb.star_bloober_count--;
                                            console.log("checking bloober "+thisOb.star_bloober_count);
                                            if(thisOb.star_bloober_count == 0
                                                    && !thisOb.star_bloobing){
                                                console.log("finn'd one:");
                                                console.log(thisOb);
                                                ob_saving_count--;
                                                if(ob_saving_count == 0
                                                        && !ob_saving){
                                                    saveotron(content);
                                                }
                                            }
                                        });
                                    });
                                }//);
                                console.log("checking bloober "+thisOb.star_bloober_count);
                                thisOb.star_bloobing = false;//RACE CONDITION HERE!
                                                            // if blob finishes between here
                                                            // and the next line there will be DOUBLE COUNTING!!!
                                if(thisOb.star_bloober_count == 0){
                                    console.log("finn'd one:");
                                    console.log(thisOb);
                                    ob_saving_count--;
                                    if(ob_saving_count == 0
                                            && !ob_saving){
                                        saveotron(content);
                                    }
                                }
                            });// end of ob loop
                            ob_saving = false; //RACE CONDITION HERE!
                            if(ob_saving_count == 0){
                                console.log("end of ob save!");
                                console.log(content);
                                setTimeout(()=>{saveotron(content)},800);
                            }

                            // there's normal competence, which is booring
                             //and there's normal incompetence which is ... all kinds of htings
                              // then theres this kind of incopmetence which is extremely charming
                                    // I will ne3ver atain that kind of incompetence... <3
                        }
                        // END OF SAVE

                        // play mode!
                        if(old_mode=="play"){
                            console.log("restoring after play");
                            selected_ob.show_stars();
                            for (let jj=0; jj<all_obs.length; jj++){
                                all_obs[jj].liner.style.visibility='';
                                all_obs[jj].style.border=all_obs[jj].pregame_border;
                                all_obs[jj].move(
                                    all_obs[jj].pregame_x - all_obs[jj].x ,
                                    all_obs[jj].pregame_y - all_obs[jj].y 
                                    );
                                if(all_obs[jj].pregame_star){
                                    all_obs[jj].pregame_star.make_current();
                                }
                                all_obs[jj].show_trigs();
                            }
                            menu.hidden=false;
                            eventMenu.hidden=false;

                        } else if(input_mode=="play"){
                            console.log("storing for play");
                            selected_ob.hide_stars();
                            for (let jj=0; jj<all_obs.length; jj++){
                                all_obs[jj].liner.style.visibility='hidden';
                                all_obs[jj].pregame_border=all_obs[jj].style.border;
                                all_obs[jj].pregame_x=all_obs[jj].x;
                                all_obs[jj].pregame_y=all_obs[jj].y;
                                all_obs[jj].style.border='hidden';
                                all_obs[jj].pregame_star=all_obs[jj].current_star;
                                all_obs[jj].hide_trigs();
                            }
                            menu.hidden=true;
                            menuhl.y.baseVal.value=5;
                            eventMenu.hidden=true;
                        }
                        break;
                    }
                }
            }
        }
        console.log(input_mode);
    }else{
        pencil_down=true;
        input_fun[input_mode][0](e);
    }
    firstx = x;
    firsty = y;
}
window.onmouseup=function(e){
    if( input_mode == 'ticktock' ){
        // over a star of the selected ob
        let stars_in_tha_skyyyy=selected_ob.starmap.wut_zones(x,y);
        if(stars_in_tha_skyyyy){
            // Make new tick!!!
            //tocking_fromStar = stars_in_tha_skyyyy[0];
            tocking_tick.add_tock(
                Tock(
                    tocking_fromStar.ob,
                    tocking_fromStar,
                    stars_in_tha_skyyyy[0]  ));
        }
        input_mode = last_input_mode;
    }else if(input_mode=='movin_menu'){
        input_mode=last_input_mode;
    }
    else if(input_mode=='zone' && pencil_down){
        //this is so bad
        drwrzonee(selected_ob,x,y,firstx,firsty);//TODO:make this get the obj it needs or not, cause just pencil tool.
        let zone = selected_ob.zones[selected_ob.zones.length-1];// hahahahahah
        mcgriddle.add(zone.xxx,zone.yyy,zone.xxx+zone.www,zone.yyy+zone.hhh,zone); // that input scheme u thought up is so bad.
                                                                                // u gotta kill & fix it
        //drwrlineee(canvas,lastx,lasty,firstx,firsty);//TODO:make this get the obj it needs or not, cause just pencil tool.
    }
    else if(input_mode=='draw'){
        //so so bad
        if(selected_ob.current_star){
            selected_ob.current_star.update();
        }
    }
    pencil_down = false;
}
////////////////
// init function
////////////////
window.onload=function(){
    console.warn("Shut up firefox! It doesn't contain any text at all!")

    window.all_obs = [];
    var w = window.innerWidth;
    var h = window.innerHeight;
    // fuck the canvas right up fukkkkkkk uuuuuuuuu
    var canvas = document.getElementById('canvas');
    canvas.style.position = 'absolute';
    canvas.style.left = '0px';
    canvas.style.top = '0px';

    // tool menu
    window.menu = document.createElement("img");
    menu.style.position = 'absolute';
    menu.style.left=10;
    menu.style.top =10;
    menu.src = "toolbar2.png";
    menu.onmousedown=function(e){e.preventDefault()};
    document.body.appendChild(menu);
    window.input_mode = 'move';

    // custom cursorz r coool!
    //document.body.style.cursor = "crosshair"
    document.body.style.cursor = "none";//window.menu;
    window.cursor = document.createElement("img");
    cursor.style.position = 'absolute';
    cursor.src = "cursor.png";
    document.body.appendChild(cursor);

    // menu for events!
    eventMenu = document.createElement("div");
    eventMenu.style.background="red";
    eventMenu.style.cursor="default";
    eventMenu.style.position = 'absolute';
    eventMenu.style.left=10;
    eventMenu.style.top=360;
    eventMenu.style.width=50;
    eventMenu.style.height=300;
    eventMenu.style.border='solid';
    eventMenu.style.borderWidth=2;
    eventMenu.style.overflow='scroll';
    window.tocking_tick=null;
    window.tocking_fromStar=null;
    eventMenu.add_tick = function(tick){
        let new_menu_tick = document.createElement("div");
        new_menu_tick.style.width=30;
        new_menu_tick.tick = tick;
        //TODO: swap these out for images
        if(tick.exit){
            new_menu_tick.innerHTML="<>";
        }else{
            new_menu_tick.innerHTML="><";
        }
        new_menu_tick.onclick = function(){
            if(input_mode!="ticktock"){
                last_input_mode = input_mode;
                input_mode = 'ticktock';
                tocking_tick = this.tick;
            }
        }

        eventMenu.insertBefore(new_menu_tick,eventMenu.firstChild);
    }
    document.body.appendChild(eventMenu);

    fuck_you=10;
    canvas.width=window.innerWidth-fuck_you;
    canvas.height=window.innerHeight-fuck_you;
    window.ctx = canvas.getContext('2d');
    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'red';
    ctx.fill();
    //drwrlineee(canvas,51,51,300,80);
    window.x=100;
    window.y=30;
    window.dx=0;
    window.dy=0;
    window.firstx=0;
    window.firsty=0;
    window.lastx=0;
    window.lasty=0;

    window.selected_ob = 'boobs';
    window.hl_ob = 'dickz';
    //testob = Ob();
    //testob = Ob();
    //window.ctx = testob.ctx;

    window.svglayer = document.getElementById("svglayer");
    svglayer.width.baseVal.value=window.innerWidth - fuck_you;
    svglayer.height.baseVal.value=window.innerHeight - fuck_you;
    window.menuhl = document.getElementById("menuhl");
    menuhl.x.baseVal.value=5;
    menuhl.y.baseVal.value=5;
    window.liner = document.getElementById("liner");
    liner.x1.baseVal.value= 1;
    liner.y1.baseVal.value= 1;
    liner.x2.baseVal.value= 2;
    liner.y2.baseVal.value= 2;
    //foo = liner.cloneNode();
    //svglayer.appendChild(foo);


    // lets get our load on!!!

//    var request = new XMLHttpRequest();
//    request.open('GET', 'gamefile.zip', true);
//    request.responseType = 'blob';
//    request.onload = function() {
//        console.log(request.response)
//        //var reader = new FileReader();
//        //reader.readAsDataURL(request.response);
//        //reader.onload =  function(e){
//            //console.log('DataURL:', e.target.result);
//        //};
//    };
//    request.send( document );


            ////////
            // Load image from file stuff!@!!!
            ///////
    function loadImg(zippo,imgnam,wheretoputit,finalFun){
        //let blobberino = new Blob([],{type: "img/png"});
        // thaks 
        // https://stackoverflow.com/questions/15970729/appending-blob-data
        // It turns out I was the Blob all along!!!o?
        // I was all 'oh I'll just grab this data and throw it in a new blob!'
        // but like, every time data got streamed, so like, I only made the
        // img with the last data that came in how silly!!!
        // ur lolling with me rite?
        let blobdata = [];
        zippo.files[imgnam].internalStream("uint8array")
            .on("data", (data)=>{
                console.log("STREAMING DATA!!!!");
                blobdata.push(data);
                //blobberino = new Blob([data], { type: "image/png" });
                //console.log(blobberino);
                //console.log(thisob);
            })
            .on("error", function (e) {console.log(imgnam,"broke");console.log("err",e);})
            .on("end", function () { 
                console.log("sdfasdfasdfasdfasdfasdfsadfasdfasdfasdfdsf");
                let blobberino = new Blob(blobdata,{type: "img/png"});

                wheretoputit.src=URL.createObjectURL(blobberino);

                console.log("finish'dasdfasd");
                finalFun();
            })
            .resume();
    }

    fetch('gamerfile5.zip').then((r)=>{//r => r.blob());
    //JSZipUtils.getBinaryContent('gamefile.zip', function(err, data) {
    //if(err) {
    //    throw err; // or handle err
    //}

        function loadImgs(zippo){
            console.log("loading imgs");
            console.log(zippo);
            console.log('fls:');
            for (var flnam in zippo.files){
                console.log(flnam);
                if (flnam.startsWith("images")
                    && flnam.endsWith(".png")){
                    console.log("yuh!",flnam);
                    let path = flnam.split("/");
                    let obNum = path[1];
                    let starflnm = path[2];
                    let starNum = starflnm.split(".")[0];

                    let thisob = all_obs[obNum];
                    console.log("should go with",thisob);

                    if (starNum.startsWith("img")){

                        console.log("got no stars",obNum);

                        let imrg = new Image();
                        imrg.onload = function(){
                            console.log("loaderd",thisob,imrg);
                            all_obs[obNum].ctx.drawImage(imrg,0,0,thisob.width,thisob.height);
                        }
                        loadImg(zippo,flnam,imrg,()=>{});

                    }else{

                        console.log("its star ",starNum);
                        console.log(thisob);
                        console.log(thisob.stars);
                        let star = thisob.stars[starNum];
                        /// make the thumbnail!!!
                        star.img.onload=()=>{
                            console.log("hello");
                            console.log(star);
                            star.ctx.clearRect(0,0,star.width,star.height);
                            let hr = star.ob.width/star.width;
                            let wr = star.ob.height/star.height;
                            // TODO: i didn't think hard enuf to make star good.
                            let scale_ratio = hr>wr?hr:wr;
                            let drwX=ob.width/scale_ratio;
                            let drwY=ob.height/scale_ratio;
                            for(let i=0;i<10;i++)
                            star.ctx.drawImage(star.img,
                                (star.width-drwX)/2+i/10,
                                (star.width-drwY)/2+i/10,
                                drwX,drwY);
                        } ///////////////////////////
                        loadImg(
                            zippo,
                            flnam,
                            star.img,
                            ()=>{
                                console.log("star callbacker ",star);
                                setTimeout(()=>{
                                    if (star.current){
                                        star.restore();
                                        //star.make_current();
                                    }
                                },300);
                            }
                        );

                    }
                }
            }
        }

        let crrstrrs = [];
        //   this needs to get done after loading and setting imgs
             //   crrstrrs.forEach((crrstrr)=>{
             //       crrstrr.make_current();
             //   });
        JSZip.loadAsync(r.blob()).then(function (zippo) {
            //// ...
            helloo = zippo.files['Hello.txt'];
            helloo.internalStream("text").on("data",function(data){
                console.log("its a text!@");
                console.log(data);
                let stuff = JSON.parse(data);
                // OBS
                stuff.Obs.forEach((thing)=>{
                    console.log("trying to make an ob");
                    console.log(thing);
                    newob = Ob();
                    newob.x=thing[1];
                    newob.y=thing[2];
                    newob.rejig();
                    newob.width=thing[3];
                    newob.height=thing[4];
                });
                // STARS
                stuff["Stars"].forEach((strrr)=>{
                    console.log(strrr);
                    let obobob = all_obs[strrr[0]];
                    obobob._new_star(strrr[1],strrr[2],strrr[3]);
                            // the underscore means its cool
                    //strrrr = Star(obobob,strrr[3]);
                    //strrrr.x = strrr[1];
                    //strrrr.y = strrr[2];
                    //strrrr.rejig();
                    //if (strrr[3]){
                        //crrstrrs.push(strrrr);
                    //}
                });

            })
                .on("error", function (e) {console.log("err",e);})
                .on("end", function () {
                    console.log("finish'd12342343");
                    loadImgs(zippo);
                })
                .resume()
            ;
            

            console.log("it's not a hippo");
            console.log(zippo);// it's not a hippo
            console.log(zippo['files']['images/0/0.png']);
            //bweebop = zippo.files['images/0/0.png'];
            window.imgee = new Image();
            imgee.onload = function(){
                //testob.width = 300;
                //testob.height = 500;
                all_obs[1].ctx.drawImage(window.imgee,0,0);
            }
          //  bweebop.internalStream("uint8array")
          //                 //string, binarystring, uint8array, arraybuffer, nodebuffer
          //      .on("data", function (data) {
          //          console.log(data);
          //          blobberino = new Blob([data], { type: "image/png" });
          //          console.log(blobberino);
          //          //testob.width=500;
          //          //testob.height=500;
          //          window.imgee.src=URL.createObjectURL(blobberino);
          //          console.log(URL.createObjectURL(blobberino));
          //          console.log(window.imgee.src);
          //          document.body.appendChild(window.imgee);
          //      })
          //      .on("error", function (e) {console.log("err",e);})
          //      .on("end", function () {console.log("finish'd12342343");})
          //      .resume();
        });
    });
}
function drwrlineee(ob,x1,y1,x2,y2){
    ctxxx = ob.getContext('2d');
    ctxxx.beginPath();
    ctxxx.moveTo(x1-ob.style.left.slice(0,-2),y1-ob.style.top.slice(0,-2));
    ctxxx.lineTo(x2-ob.style.left.slice(0,-2),y2-ob.style.top.slice(0,-2));
    ctxxx.stroke();
}
function drwrzonee(ob,x1,y1,x2,y2){
    foo = liner.cloneNode();
    zoo = ob.zones[ob.zones.length-1];
    zoo.appendChild(foo);
    foo.x1.baseVal.value = x1 - zoo.xxx;
    foo.y1.baseVal.value = y1 - zoo.yyy;
    foo.x2.baseVal.value = x2 - zoo.xxx;
    foo.y2.baseVal.value = y2 - zoo.yyy;
    // resize if drawing outside
    if(x2>zoo.xxx+zoo.www){
        zoo.www = x2-zoo.xxx;
        zoo.resize();
    }else if (x2<zoo.xxx){
        zoo.www += zoo.xxx-x2;
        zoo.resize();
        zoo.movelines(zoo.xxx-x2,0);
        zoo.xxx = x2;
        zoo.rejig();
    }
    if(y2>zoo.yyy+zoo.hhh){
        zoo.hhh = y2-zoo.yyy;
        zoo.resize();
    }else if (y2<zoo.yyy){
        zoo.hhh += zoo.yyy-y2;
        zoo.resize();
        zoo.movelines(0,zoo.yyy-y2);
        zoo.yyy = y2;
        zoo.rejig();
    }

}
// this is neat... delete it!!!!!
function move(){
      bx = document.getElementById("box");

      hereXstr = bx.style.left;//.slice(0,bx.style.left.length-2);
      hereXstr.replace("px","");
      hereX = parseInt(hereXstr);

      hereYstr = bx.style.top;
      hereYstr.replace("px","");
      hereY = parseInt(hereYstr);

      thereX = x;
      thereY = y;

      newX = (4*hereX+thereX)/5;
      newY = (4*hereY+thereY)/5;
      bx.style.left = newX;
      bx.style.top = newY;

      if(Math.abs(thereX-hereX)>7 || Math.abs(thereY-hereY)>7)
          doing = 1;
          //setTimeout(function(){move(x,y);}, 100);
}
trig=null;
function m(e){
//       if(goobable){
//          goobable = false;
        lastx = x;
        lasty = y;
        x = e.pageX;
        y = e.pageY;
        dx = x-lastx;
        dy = y-lasty;
        if(pencil_down){
            input_fun[input_mode][1](e);
        }else{
            input_fun[input_mode][2](e);
        }
    //move cursor
        cursor.style.top = y;
        cursor.style.left = x;
//     } // goobable was a dum idea.
    }
 // window.goobable = false;
 // function goob(){
 //     goobable = true;
 // }
 //   window.setInterval(goob, 100);// doesn't even help with the multi babb issue.
</script>
</head>
<body>
    <canvas id="canvas"></canvas>
    <svg id="svglayer" width="400" height="1000" style="position:absolute">
      <rect id="menuhl" x=100 y=100 width="38" height="38" style="fill:rgb(2550,100,100);stroke-width:4;stroke:rgb(0,0,0)" />
      <line id="liner" x1="0" y1="0" x2="300" y2="300" style="stroke:rgb(255,255,255);stroke-width:2" />
    </svg>
</body>
</html>
<!--1200 lines of code! Hawt!>
